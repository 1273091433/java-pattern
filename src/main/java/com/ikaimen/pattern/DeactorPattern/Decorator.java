package com.ikaimen.pattern.DeactorPattern;

/**
 * Created by ChenTao on 2017/8/25.
 *
 * 抽象装饰者
 *
 * 装饰者模式定义
 *
 * 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活。
 *
 * 装饰者模式的优缺点
 *
 * 优点：
 *
 * 装饰类和被修饰类可以独立发展，而不会相互耦合。换句话说，Component类无须知道知道Decorate类。Decorate类是从外部来扩展Component类的功能，而Decorator也不用知道具体的构建
 *
 * 装饰模式是继承关系的替代方案。我们看装饰类Decorate，不管装饰多少层，返回的对象还是Component,实现的还是is-a的关系。
 *
 * 装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此。
 *
 * 缺点：
 *
 * 对于装饰模式记住一点就足够了：多层的装饰是比较复杂的。为什么复杂呢？你想想看，就像剥洋葱一样，你剥到了最后才发现是最里面的装饰器出现了问题，想想一下工作量吧，因此，尽量减少
 * 装饰类的数量，以便降低系统的复杂度。
 *
 * 装饰模式的使用场景
 *
 * 需要扩展一个类的功能，或给一个类增加附加功能
 *
 * 需要动态地给一个对象增加功能，这些功能可以在动态地撤销
 *
 * 需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式
 *
 * 最佳实践
 *
 * 装饰模式是对继承的有力补充。你要知道继承不是万能的。继承可以解决实际的问题，但是在项目中你要考虑诸如易维护，易扩展，易复用等，而且在一些情况下（比如上面那个成绩单例子）你要是
 * 用继承就会增加很多子类，而且灵活性非常差，那当然维护也不容易了，也就是说装饰模式可以替代继承，解决我们类膨胀的问题。同时，你还要知道继承是静态地给类增加功能，而装饰模式则是动态
 * 地增加功能，在上面的那个例子中，我不想要SortDecorate这层的封装也很简单，于是直接在father中去掉就可以了，如果你用继承就必须修改程序。
 *
 * 装饰模式还有一个非常好的优点：扩展性非常的好。在一个项目中，你会有非常多的因素考虑不到，特别是业务的 变更，不时地冒出一个需求，尤其是提出一个令项目大量延迟的需求时，那种心情是
 * 相当的难受！装饰模式可以给我们提供很好的帮助，通过装饰模式重新封装一个类，而不是通过继承来完成，简单点说，三个继承关系Father，Son，GrandSon三个类，我要在Son类上增强一些功能
 * 怎么办？我想你会坚决的顶回去！不允许，对了，为什么了？你增强的功能是修改Son类中的方法吗？增加方法吗？对GrandSon的影响呢？特别是GrandSon有多个的情况，你会怎么办？这个评估的工
 * 作量就够你受了，所以这是不允许的，那还是要交解决问题的呀，怎么办？通过建立SonDecorator类来修饰Son，相当于创建了一个新的类，这个对原有程序没有变更，通过扩展很好的完成了这次变更。
 *
 */
public abstract class Decorator extends Component {

    private Component component = null;

    //通过构造函数传递被修饰者

    public Decorator(Component component){

        this.component = component;
    }

    //委托给被修饰着执行
    @Override
    public void operate(){

        this.component.operate();

    }
}
