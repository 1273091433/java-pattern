package com.ikaimen.pattern.VisitorPattern;

/**
 * @Author: Mr.Chen
 *
 * @Description: 访问者模式
 *
 * @Date: Created in 2017/9/24 下午6:38
 *
 *
 * 定义：
 *
 * 封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
 *
 * 访问者模式的优点：
 *
 * 符合单一职责原则
 *
 * 具体元素角色也就是Employee抽象类的两个子类负责数据的加载，而Visitor类则负责报表的展现，两个不同的职责非常明确地分离开来，各自演绎变化。
 *
 * 优秀的扩展性
 *
 * 由于职责分开，继续添加对数据的操作是非常快捷的，例如现在要增加一分给老大的报表，这份报表格式又有所不同，直接在Visitor中增加一个方法，传
 * 递数据后整理打印。
 *
 * 灵活性非常高
 *
 * 缺点：
 *
 * 具体元素对访问者公布细节
 *
 * 访问者要访问一个类就必然要求这个类公布一些方法和数据，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的。
 *
 * 具体元素变更比较困难
 *
 * 具体元素角色的增加，删除，修改都是比较困难的，就上面那个例子，你想想，你要是想增加一个成员变量，如年龄，age,Visitor 就需要修改，如果Visitor是
 * 一个还好，多个呢？业务逻辑再复杂点呢？
 *
 * 违背了依赖倒置的原则
 *
 * 访问者依赖的具体元素，而不是抽象元素，这破坏了依赖倒置原则，特别是在面向对象的编程中，抛弃了对接口的依赖，二直接依赖实现类，扩展比较困难。
 *
 *
 * 访问者模式的使用场景：
 *
 * 一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于其具体类的操作，也就是说用迭代器模式已经不能胜任的情景
 *
 * 需要对一个对象结构中的对象进行很多不同并且不相关的操作，而你想避免让这些操作"污染"这些对象的类。
 *
 * 最佳实践：
 *
 * 访问者模式是一种集中规整模式，特别适用于大规模重构的项目，在这一个阶段需求已经非常清晰，原系统的功能点也已经明确，通过访问者模式可以很容易吧一些
 * 功能进行梳理，达到最终目的----功能集中化，如一个统一的报表运算。UI展现等，我们还可以与其他模式混编，建立一套自己的过滤器和拦截器。
 *
 **/
public  interface IVisitor {

    //可以访问哪些对象

    public void visit(ConcreteElement1 element1);


    public void visit(ConcreteElement2 element2);

}
